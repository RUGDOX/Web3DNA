/**
 * Web3DNA SDK v1.0.0
 * Unmask Protocol (by Rugdox LLC)
 * Secure identity fingerprinting for Web3 authentication and fraud prevention
 */
(function(global) {
  const Web3DNA = {};

  // ========== UTILITY FUNCTIONS ==========
  
  /**
   * Generate SHA-256 hash from message
   * @param {string} message - Input message to hash
   * @returns {Promise<string>} - Hex-encoded hash
   */
  async function sha256(message) {
    const msgBuffer = new TextEncoder().encode(message);
    const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
    return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
  }

  /**
   * Generate HMAC-SHA256 signature
   * @param {string} secret - Secret key
   * @param {string} message - Message to sign
   * @returns {Promise<string>} - Hex-encoded signature
   */
  async function hmacSha256(secret, message) {
    const enc = new TextEncoder();
    const key = await crypto.subtle.importKey(
      "raw", 
      enc.encode(secret), 
      { name: "HMAC", hash: "SHA-256" }, 
      false, 
      ["sign"]
    );
    const sig = await crypto.subtle.sign("HMAC", key, enc.encode(message));
    return Array.from(new Uint8Array(sig)).map(b => b.toString(16).padStart(2, '0')).join('');
  }

  /**
   * Safely access browser properties with fallback
   * @param {Function} fn - Function to try
   * @param {*} fallback - Fallback value if function fails
   * @returns {*} - Result or fallback
   */
  function safeGet(fn, fallback = 'unavailable') {
    try { 
      return fn(); 
    } catch { 
      return fallback; 
    }
  }

  // ========== FINGERPRINTING MODULES ==========
  
  /**
   * Get WebGL renderer and vendor information
   * @returns {string} - WebGL fingerprint
   */
  function getWebGLFingerprint() {
    try {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      if (!gl) return 'webgl_unsupported';
      
      const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
      if (!debugInfo) return 'webgl_no_debug_info';
      
      const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
      const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
      
      return `${vendor}|${renderer}`;
    } catch (e) {
      return 'webgl_error';
    }
  }

  /**
   * Get audio processing fingerprint
   * @returns {Promise<string>} - Audio fingerprint hash
   */
  async function getAudioFingerprint() {
    try {
      const context = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = context.createOscillator();
      const analyser = context.createAnalyser();
      const gain = context.createGain();
      const processor = context.createScriptProcessor(4096, 1, 1);

      oscillator.type = 'triangle';
      oscillator.frequency.setValueAtTime(10000, context.currentTime);
      oscillator.connect(analyser);
      analyser.connect(processor);
      processor.connect(gain);
      gain.connect(context.destination);

      oscillator.start(0);
      return await new Promise((resolve) => {
        processor.onaudioprocess = function (event) {
          const out = event.inputBuffer.getChannelData(0).slice(0, 50);
          oscillator.stop();
          processor.disconnect();
          gain.disconnect();
          context.close();
          resolve(sha256(out.toString()));
        };
      });
    } catch (e) {
      return 'audio_error';
    }
  }

  /**
   * Get canvas fingerprint
   * @returns {string} - Canvas fingerprint
   */
  function getCanvasFingerprint() {
    try {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 240;
      canvas.height = 60;
      
      // Text with different styles and emojis
      ctx.textBaseline = 'top';
      ctx.font = "16px 'Arial'";
      ctx.fillStyle = "#F0A030";
      ctx.fillText('Web3DNA Fingerprint üîí', 2, 2);
      
      // Add some shapes
      ctx.beginPath();
      ctx.moveTo(20, 20);
      ctx.lineTo(60, 40);
      ctx.lineTo(20, 40);
      ctx.closePath();
      ctx.fillStyle = "#3080F0";
      ctx.fill();
      
      // Add gradient
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
      gradient.addColorStop(0, "red");
      gradient.addColorStop(0.5, "blue");
      gradient.addColorStop(1, "green");
      ctx.fillStyle = gradient;
      ctx.fillRect(80, 10, 120, 30);
      
      return canvas.toDataURL();
    } catch (e) {
      return 'canvas_error';
    }
  }

  /**
   * Check IP information and risk factors
   * @param {string} ipApiServer - Optional custom IP API endpoint
   * @returns {Promise<Object>} - IP info with risk assessment
   */
  async function checkIPRiskNoKey(ipApiServer = 'https://ip-api.io/json') {
    try {
      const res = await fetch(ipApiServer);
      const data = await res.json();
      
      const asn = (data.asn || '').toLowerCase();
      const suspiciousProviders = [
        "digitalocean", "ovh", "contabo", "linode", "hetzner", 
        "vultr", "cloudflare", "amazon", "azure", "google"
      ];
      
      const match = suspiciousProviders.some(name => asn.includes(name));
      const suspicious = !!data.proxy || match;
      
      return {
        ip: data.ip,
        country: data.country,
        isp: data.connection?.isp || 'unknown',
        proxy: data.proxy || false,
        asn: data.asn || '',
        suspicious,
        tag: suspicious ? '‚ö†Ô∏è Suspicious (Possible VPN/Proxy)' : 'üõ°Ô∏è Safe'
      };
    } catch (e) {
      return {
        ip: 'unavailable',
        proxy: false,
        suspicious: false,
        tag: '‚ùì Unknown (API Failed)'
      };
    }
  }

  /**
   * Collect comprehensive fingerprint data
   * @param {boolean} verbose - Whether to log details to console
   * @returns {Promise<Object>} - Fingerprint data and hash
   */
  async function collectDeviceFingerprint(verbose = false) {
    // Basic navigator and screen properties
    const signals = {
      userAgent: safeGet(() => navigator.userAgent),
      language: safeGet(() => navigator.language),
      languages: safeGet(() => Array.from(navigator.languages || []).join(',')),
      platform: safeGet(() => navigator.platform),
      hardwareConcurrency: safeGet(() => navigator.hardwareConcurrency),
      deviceMemory: safeGet(() => navigator.deviceMemory),
      screen: `${screen.width}x${screen.height}`,
      colorDepth: safeGet(() => screen.colorDepth),
      pixelRatio: safeGet(() => window.devicePixelRatio),
      
      // Time and region
      timezone: safeGet(() => Intl.DateTimeFormat().resolvedOptions().timeZone),
      timezoneOffset: safeGet(() => new Date().getTimezoneOffset()),
      
      // Browser features
      doNotTrack: safeGet(() => navigator.doNotTrack),
      cookiesEnabled: safeGet(() => navigator.cookieEnabled),
      localStorage: safeGet(() => !!window.localStorage),
      sessionStorage: safeGet(() => !!window.sessionStorage),
      indexedDB: safeGet(() => !!window.indexedDB),
      
      // Plugins and MIME types
      plugins: safeGet(() => {
        return Array.from(navigator.plugins || [])
          .map(p => `${p.name}::${p.filename}`).join(',');
      }),
      
      // Advanced fingerprinting
      touchPoints: safeGet(() => navigator.maxTouchPoints),
      webgl: getWebGLFingerprint(),
      canvas: getCanvasFingerprint(),
      audio: await getAudioFingerprint(),
      
      // Network info
      ipinfo: await checkIPRiskNoKey()
    };

    // Convert all signal data to string and join
    const raw = Object.entries(signals)
      .map(([key, value]) => `${key}:${
        typeof value === 'object' ? JSON.stringify(value) : String(value)
      }`)
      .join('|');
    
    // Generate fingerprint hash
    const fingerprint = await sha256(raw);

    // Log if verbose mode enabled
    if (verbose) {
      console.group('Web3DNA Fingerprint Data');
      console.table(signals);
      console.log('Raw Signal Length:', raw.length);
      console.log('Web3DNA Fingerprint:', fingerprint);
      console.log('IP Risk Tag:', signals.ipinfo.tag);
      console.groupEnd();
    }

    return { 
      fingerprint, 
      rawSignals: signals,
      timestamp: new Date().toISOString(),
      suspicious: signals.ipinfo.suspicious
    };
  }

  // ========== CORE ID FUNCTIONS ==========
  
  /**
   * Generate identity signature from personal data
   * @param {Object} params - Identity parameters
   * @param {string} params.name - Full legal name
   * @param {string} params.dob - Date of birth (YYYY-MM-DD)
   * @param {string} params.selfieVector - Selfie image vector hash
   * @param {string} params.idNumber - Government-issued ID number
   * @returns {Promise<Object>} - Identity hash
   */
  async function generateIdentitySignature({ 
    name, 
    dob, 
    selfieVector, 
    idNumber 
  }) {
    // Normalize inputs to prevent minor differences
    const normalizedName = name.toLowerCase().trim();
    const normalizedDob = dob.trim();
    const normalizedIdNumber = idNumber.replace(/[\s-]/g, '').toUpperCase();
    
    // Create combined input with separation
    const input = `${normalizedName}|${normalizedDob}|${selfieVector}|${normalizedIdNumber}`;
    
    // Hash the identity data
    const identityHash = await sha256(input);
    
    return { 
      identityHash,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Generate complete Web3DNA hash from identity and device data
   * @param {string} identityHash - Identity signature hash
   * @param {string} deviceHash - Device fingerprint hash
   * @param {string} secret - Optional secret for HMAC (server-side)
   * @param {boolean} useHmac - Whether to use HMAC instead of plain SHA-256
   * @returns {Promise<string>} - Combined Web3DNA hash
   */
  async function generateWeb3DNA(
    identityHash, 
    deviceHash, 
    secret = '', 
    useHmac = false
  ) {
    // Date-based nonce for uniqueness
    const timestamp = new Date().toISOString();
    const nonce = Math.floor(Math.random() * 1000000).toString();
    
    // Create combined data with context separation
    const combo = `${identityHash}|${deviceHash}|${timestamp}|${nonce}|${secret}`;
    
    // Generate final hash with either HMAC or SHA-256
    return useHmac 
      ? await hmacSha256(secret, combo) 
      : await sha256(combo);
  }

  /**
   * Submit fingerprint to Web3DNA registry
   * @param {string} platformId - Platform identifier 
   * @param {string} walletAddress - User's wallet address
   * @param {boolean} debug - Enable verbose logging
   * @param {string} endpoint - Server endpoint
   * @returns {Promise<Object>} - Server response
   */
  async function submitFingerprint(
    platformId, 
    walletAddress, 
    debug = false,
    endpoint = "https://api.unmask.io/dna/submit"
  ) {
    // Collect device fingerprint
    const { fingerprint, rawSignals, suspicious } = await collectDeviceFingerprint(debug);
    
    // Calculate risk score
    let riskScore = 0;
    const tags = [];
    
    // Check for suspicious browser environment 
    if (rawSignals.userAgent.includes("Headless")) {
      riskScore += 25;
      tags.push("headless");
    }
    
    // Check for data inconsistency (timezone vs IP)
    if (rawSignals.ipinfo.country && rawSignals.timezone) {
      const tzCountry = rawSignals.timezone.split('/')[0];
      if (tzCountry !== rawSignals.ipinfo.country) {
        riskScore += 15;
        tags.push("geo_mismatch");
      }
    }
    
    // Add IP-based risk
    if (suspicious) {
      riskScore += 30;
      tags.push("proxy_vpn");
    }
    
    // Add additional scoring factors
    if (!rawSignals.cookiesEnabled) {
      riskScore += 10;
      tags.push("no_cookies");
    }
    
    if (rawSignals.plugins.length < 5) {
      riskScore += 5;
      tags.push("few_plugins");
    }

    // Prepare payload
    const payload = {
      dna_hash: fingerprint,
      platform_id: platformId,
      wallet: walletAddress,
      timestamp: new Date().toISOString(),
      risk_score: riskScore,
      tags: tags,
      suspicious: suspicious || riskScore > 50
    };

    // In debug mode, also include signal data
    if (debug) {
      payload.debug = { signals: rawSignals };
    }

    try {
      // Submit to server
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
      
      // Parse response
      const result = await response.json();
      
      // Log if debug enabled
      if (debug) {
        console.log('Web3DNA Submission:', {
          sent: payload,
          received: result
        });
      }
      
      return result;
    } catch (error) {
      // Handle error
      if (debug) {
        console.error('Web3DNA Submission Error:', error);
      }
      
      return {
        status: 'error',
        error: error.message || 'Unknown error',
        dna_hash: fingerprint,
        offline: true
      };
    }
  }

  // ========== EXPORT PUBLIC API ==========
  
  Web3DNA.collectDeviceFingerprint = collectDeviceFingerprint;
  Web3DNA.generateIdentitySignature = generateIdentitySignature;
  Web3DNA.generateWeb3DNA = generateWeb3DNA;
  Web3DNA.checkIPRiskNoKey = checkIPRiskNoKey;
  Web3DNA.submitFingerprint = submitFingerprint;
  Web3DNA.version = '1.0.0';

  // Feature detection (used for browser/node compatibility check)
  Web3DNA.isCompatible = function() {
    return typeof window !== 'undefined' && 
           typeof crypto !== 'undefined' && 
           typeof crypto.subtle !== 'undefined' &&
           typeof window.fetch !== 'undefined';
  };

  // Add to global scope
  global.Web3DNA = Web3DNA;
  
  // Support CommonJS/AMD environments
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Web3DNA;
  } else if (typeof define === 'function' && define.amd) {
    define([], function() { return Web3DNA; });
  }
  
})(typeof window !== 'undefined' ? window : (typeof global !== 'undefined' ? global : this));
